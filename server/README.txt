1. 普通用户只能监听1024及以上的端口，root用户可以监听任意端口
2. listen 的第二个参数指定已连接对列的大小，请求的客户端大于该数值时，将处于半连接状态
3. 客户端socket也有端口号，但不必关系，所以由系统自动分配
4. socket通信的地址包括ip+port，但习惯上地址仅仅指ip
5.  //设置socket选项
    //输入CTRL+C关闭服务端时
    //服务器发送FIN断开后并非立即消除，而是会有Time-wait状态，防止断开那一端（例如A端）的ACK消息在向B端传输过程中丢失
    //所以会有一段Time-wait时间，再次以同一个端口启动服务端时会报address already in use
    //这个address already in use状态会保持一段时间（一般30-200s）
    //time_wait状态可通过netstat查看
    //解决方案：在套接字的可选项中更改 SO_REUSEADDR的状态（其默认值为0）将其改为1
    //下面两行代码一定要在bind之前
    // bool bReuseaddr = true;
    // setsockopt(m_listen_fd,SOL_SOCKET,SO_REUSEADDR, &bReuseaddr,sizeof(bReuseaddr));

    //主动断开的端在四次挥手之后socket进入timewait状态，该状态将持续2MSL
    //MSL为报文在网络上存在的最长时间，超过这个时间报文将被丢弃
    //如果是客户端主动断开，几乎不会造成影响
    //如果是服务端主动断开，有两方面危害：
            1.socket未立即释放
            2.端口号只能在2MSL后才能重新使用(测试时好像是在客户端未断开而服务端断开时进入该状态)

6. 系统为每个socket创建了发送接收缓冲区，程序调用recv/read系统调用时，内核将数据从socket的接收缓冲区拷贝到应用用户空间，同理，应用程序调用send/write时，内核将数据从用户空间搬运到内核socket的发送缓冲区中
7. send函数会阻塞吗？ 会，当接收方不能及时处理缓冲区数据时，接收缓冲区将被填满，此时发送端发送将被阻塞
8. 想socket写入数据后，关闭了socket，接收端能否收到数据？ 会，数据写入缓冲区后，将由硬件转发到接收端的接收缓冲区
9. Nagle算法



多进程/线程的网络服务 每连接一个客户端，就要创建一个进程/线程，消耗资源很多
IO多路复用可以用一个进程/线程处理多个TCP连接，减少系统开销 
IO多路复用（Input/Output Multiplexing）是一种在单个线程中管理多个输入/输出通道的技术。
它允许一个线程同时监听多个输入流（例如网络套接字、文件描述符等），并在有数据可读或可写时进行相应的处理，而不需要为每个通道创建一个独立的线程


    /* 
     * 读事件：
     * 1.已连接队列有就绪的socket
     * 2.接收缓冲区有数据可以读取
     * 3.有socket断开连接
     * 
     * 写事件：
     * 1.发送缓冲区未满
     */

1.select ：一个进程/线程可以处理1024个连接 ：socket集合用一个int[32]进行bitmap，4×8×32 = 1024
    因为在select内部会修改bitmap,因此每次调用select前都需要进行拷贝，程序在用户态，网络通信在内核，因此bitmap拷贝了两次，开销较大
    bitmap的大小决定了单个进程/线程处理socket的数量
    为什么不用更大的数组进行bitmap？？？  ---- 答：该变量默认为32个，由宏控制，可更改，但是bitmap采用轮寻的方式，故bitmap越大，效率越低
2.poll ： 。。。。。处理数千
    与select模型类似，仅做了一点点改变：poll用结构体数组，只需拷贝一次（用户态->内核态）
    poll连接数由结构体数组大小决定，也是轮寻的方法，同样监视的越多，效率越低
    通常在tcp读用一个结构体大小的poll，主要利用其超时机制,来等待一段时间再读取
 3.epoll ：。。。。。处理百万 
    不需要每次都遍历整个数组，有多少事件就处理多少事件


阻塞和非阻塞IO（重要）
网络通信中默认为阻塞的函数：connect（三次握手会阻塞，只是时间短而已 ），accept，send/write，recv/read
IO多路复用需要使用非阻塞IO,事件循环不能在任何地方阻塞，否则整个事件循环将停止，便无法监视其他socket
上述四个函数非阻塞的写法

设置IO为阻塞和非阻塞的对象是文件描述符号，针对该文件描述符的操作设置为阻塞和非阻塞 O_NONBLOCK
可以在打开文件时设置，也可后续用fcntl修改文件描述符的状态

注意：将socket设为非阻塞时：
针对connect()：  无论成功还是失败，都将返回失败，需要通过erro判定，如果errno != EINPROGRESS，可以判定为失败
                但如果是，则需要借助文件描述符的写状态，如果可写，则连接成功，否则失败（通过select/poll/epoll监听写事件配合超时判定）
针对accept()：   若连接队列没有socket，立即返回失败，erro=EAGAIN
针对recv()：     若缓冲区为空，立即返回失败，errno=EAGAIN
针对send()：     若缓冲区已满，立即返回失败，errno=EAGAIN


水平触发(LT)和边缘(ET)触发:针对事件未被处理时是否会再次触发
    select和poll采用水平触发; epoll两种机制都有，默认为水平触发
    水平触发：会，直到事件被处理
    边缘触发：不会，只触发一次
        触发读事件后，不论程序有无处理，后续均不会再触发，只有当新数据到达时，才会再次触发
        触发写事件后，若缓冲区仍可写，不会再次触发写事件，只有当缓冲区由满->不满时，才会再次触发
    
    水平触发和边缘触发对accept和read处理不同，因为边缘触发对于一次就绪事件只会触发一次，所以需要一次性的把缓冲区的数据读完为止，
    也就是一直读，直到读到缓冲区为空为止，因为这一点，边缘触发需要设置文件句柄为非阻塞
    水平触发的代码不能用于边缘触发，但边缘触发的代码可以用于水平触发

注：epoll的每个细节都很重要，面试最最最重点

在IO复用模型中，不会用到阻塞IO，因为很容易产生BUG


--------------------------------------------------------------------------------------
------------------------------------网上找的相关资料-------------------------------------
--------------------------------------------------------------------------------------
扩展到reactor（I/O 复用 + 线程池）
    epoll的不足是如果当epoll_wait()方法返回了10w个就绪事件，就需要等待这10w个就绪事件处理完成，
    才能继续下面的命令，去响应新的事件，这样就容易让新的事件超时。因此，提出了Reactor模型

I/O 复用 + 线程池，就是 Reactor 模式基本设计思想：
Reactor 模式，通过一个或多个输入同时传递给服务处理器的模式(基于事件驱动)
服务器端程序处理传入的多个请求,并将它们同步分派到相应的处理线程， 因此Reactor模式也叫 Dispatcher模式
Reactor 模式使用IO复用监听事件, 收到事件后，分发给某个线程(进程), 这点就是网络服务器高并发处理关键
--------------------------------------------------------------------------------------

TCP报文的缺省字节为1460个Byte

常用分包方法：
1.采用固定长度发送
2.增加头部信息，如包字节数等 
3.增加结束符号，例如http协议用\r\n\r\n

在reactor模型中，每个connection都有一个rxbuf和一个txbuf
